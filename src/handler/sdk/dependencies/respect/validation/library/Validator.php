<?php
 namespace Respect\Validation; use finfo; use ReflectionClass; use Respect\Validation\Exceptions\AllOfException; use Respect\Validation\Exceptions\ComponentException; use Respect\Validation\Exceptions\ValidationException; use Respect\Validation\Rules\AllOf; use Respect\Validation\Rules\Key; class Validator extends AllOf { protected static $factory; protected static function getFactory() { if (!static::$factory instanceof Factory) { static::$factory = new Factory(); } return static::$factory; } public static function setFactory($factory) { static::$factory = $factory; } public static function with($rulePrefix, $prepend = false) { if (false === $prepend) { self::getFactory()->appendRulePrefix($rulePrefix); } else { self::getFactory()->prependRulePrefix($rulePrefix); } } public function check($input) { try { return parent::check($input); } catch (ValidationException $exception) { if (count($this->getRules()) == 1 && $this->template) { $exception->setTemplate($this->template); } throw $exception; } } public static function __callStatic($ruleName, $arguments) { if ('allOf' === $ruleName) { return static::buildRule($ruleName, $arguments); } $validator = new static(); return $validator->__call($ruleName, $arguments); } public static function buildRule($ruleSpec, $arguments = []) { try { return static::getFactory()->rule($ruleSpec, $arguments); } catch (\Exception $exception) { throw new ComponentException($exception->getMessage(), $exception->getCode(), $exception); } } public function __call($method, $arguments) { return $this->addRule(static::buildRule($method, $arguments)); } protected function createException() { return new AllOfException(); } public static function create() { $ref = new ReflectionClass(__CLASS__); return $ref->newInstanceArgs(func_get_args()); } } 