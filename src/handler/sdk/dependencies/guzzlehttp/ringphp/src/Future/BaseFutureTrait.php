<?php
namespace GuzzleHttp\Ring\Future; use GuzzleHttp\Ring\Exception\CancelledFutureAccessException; use GuzzleHttp\Ring\Exception\RingException; use React\Promise\PromiseInterface; trait BaseFutureTrait { private $waitfn; private $cancelfn; private $wrappedPromise; private $error; private $result; private $isRealized = false; public function __construct( PromiseInterface $promise, callable $wait = null, callable $cancel = null ) { $this->wrappedPromise = $promise; $this->waitfn = $wait; $this->cancelfn = $cancel; } public function wait() { if (!$this->isRealized) { $this->addShadow(); if (!$this->isRealized && $this->waitfn) { $this->invokeWait(); } if (!$this->isRealized) { $this->error = new RingException('Waiting did not resolve future'); } } if ($this->error) { throw $this->error; } return $this->result; } public function promise() { return $this->wrappedPromise; } public function then( callable $onFulfilled = null, callable $onRejected = null, callable $onProgress = null ) { return $this->wrappedPromise->then($onFulfilled, $onRejected, $onProgress); } public function cancel() { if (!$this->isRealized) { $cancelfn = $this->cancelfn; $this->waitfn = $this->cancelfn = null; $this->isRealized = true; $this->error = new CancelledFutureAccessException(); if ($cancelfn) { $cancelfn($this); } } } private function addShadow() { $this->wrappedPromise->then( function ($value) { $this->isRealized = true; $this->result = $value; $this->waitfn = $this->cancelfn = null; }, function ($error) { $this->isRealized = true; $this->error = $error; $this->waitfn = $this->cancelfn = null; } ); } private function invokeWait() { try { $wait = $this->waitfn; $this->waitfn = null; $wait(); } catch (\Exception $e) { $this->error = $e; $this->isRealized = true; } } } 