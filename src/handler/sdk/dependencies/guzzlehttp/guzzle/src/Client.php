<?php
namespace GuzzleHttp; use GuzzleHttp\Event\HasEmitterTrait; use GuzzleHttp\Message\MessageFactory; use GuzzleHttp\Message\MessageFactoryInterface; use GuzzleHttp\Message\RequestInterface; use GuzzleHttp\Message\FutureResponse; use GuzzleHttp\Ring\Core; use GuzzleHttp\Ring\Future\FutureInterface; use GuzzleHttp\Exception\RequestException; use React\Promise\FulfilledPromise; use React\Promise\RejectedPromise; class Client implements ClientInterface { use HasEmitterTrait; private $messageFactory; private $baseUrl; private $defaults; private $fsm; public function __construct(array $config = []) { $this->configureBaseUrl($config); $this->configureDefaults($config); if (isset($config['emitter'])) { $this->emitter = $config['emitter']; } $this->messageFactory = isset($config['message_factory']) ? $config['message_factory'] : new MessageFactory(); if (isset($config['fsm'])) { $this->fsm = $config['fsm']; } else { if (isset($config['handler'])) { $handler = $config['handler']; } elseif (isset($config['adapter'])) { $handler = $config['adapter']; } else { $handler = Utils::getDefaultHandler(); } $this->fsm = new RequestFsm($handler, $this->messageFactory); } } public function getDefaultOption($keyOrPath = null) { return $keyOrPath === null ? $this->defaults : Utils::getPath($this->defaults, $keyOrPath); } public function setDefaultOption($keyOrPath, $value) { Utils::setPath($this->defaults, $keyOrPath, $value); } public function getBaseUrl() { return (string) $this->baseUrl; } public function createRequest($method, $url = null, array $options = []) { $options = $this->mergeDefaults($options); $options['config']['emitter'] = clone $this->getEmitter(); $url = $url || (is_string($url) && strlen($url)) ? $this->buildUrl($url) : (string) $this->baseUrl; return $this->messageFactory->createRequest($method, $url, $options); } public function get($url = null, $options = []) { return $this->send($this->createRequest('GET', $url, $options)); } public function head($url = null, array $options = []) { return $this->send($this->createRequest('HEAD', $url, $options)); } public function delete($url = null, array $options = []) { return $this->send($this->createRequest('DELETE', $url, $options)); } public function put($url = null, array $options = []) { return $this->send($this->createRequest('PUT', $url, $options)); } public function patch($url = null, array $options = []) { return $this->send($this->createRequest('PATCH', $url, $options)); } public function post($url = null, array $options = []) { return $this->send($this->createRequest('POST', $url, $options)); } public function options($url = null, array $options = []) { return $this->send($this->createRequest('OPTIONS', $url, $options)); } public function send(RequestInterface $request) { $isFuture = $request->getConfig()->get('future'); $trans = new Transaction($this, $request, $isFuture); $fn = $this->fsm; try { $fn($trans); if ($isFuture) { return $trans->response instanceof FutureInterface ? $trans->response : new FutureResponse(new FulfilledPromise($trans->response)); } while ($trans->response instanceof FutureInterface) { $trans->response = $trans->response->wait(); } return $trans->response; } catch (\Exception $e) { if ($isFuture) { return new FutureResponse(new RejectedPromise($e)); } throw RequestException::wrapException($trans->request, $e); } catch (\TypeError $error) { $exception = new \Exception($error->getMessage(), $error->getCode(), $error); if ($isFuture) { return new FutureResponse(new RejectedPromise($exception)); } throw RequestException::wrapException($trans->request, $exception); } } protected function getDefaultOptions() { $settings = [ 'allow_redirects' => true, 'exceptions' => true, 'decode_content' => true, 'verify' => true ]; if (php_sapi_name() == 'cli' && getenv('HTTP_PROXY')) { $settings['proxy']['http'] = getenv('HTTP_PROXY'); } if ($proxy = getenv('HTTPS_PROXY')) { $settings['proxy']['https'] = $proxy; } return $settings; } private function buildUrl($url) { if (!is_array($url)) { return strpos($url, '://') ? (string) $url : (string) $this->baseUrl->combine($url); } if (!isset($url[1])) { throw new \InvalidArgumentException('You must provide a hash of ' . 'varname options in the second element of a URL array.'); } if (strpos($url[0], '://')) { return Utils::uriTemplate($url[0], $url[1]); } return (string) $this->baseUrl->combine( Utils::uriTemplate($url[0], $url[1]) ); } private function configureBaseUrl(&$config) { if (!isset($config['base_url'])) { $this->baseUrl = new Url('', ''); } elseif (!is_array($config['base_url'])) { $this->baseUrl = Url::fromString($config['base_url']); } elseif (count($config['base_url']) < 2) { throw new \InvalidArgumentException('You must provide a hash of ' . 'varname options in the second element of a base_url array.'); } else { $this->baseUrl = Url::fromString( Utils::uriTemplate( $config['base_url'][0], $config['base_url'][1] ) ); $config['base_url'] = (string) $this->baseUrl; } } private function configureDefaults($config) { if (!isset($config['defaults'])) { $this->defaults = $this->getDefaultOptions(); } else { $this->defaults = array_replace( $this->getDefaultOptions(), $config['defaults'] ); } if (!isset($this->defaults['headers'])) { $this->defaults['headers'] = [ 'User-Agent' => Utils::getDefaultUserAgent() ]; } elseif (!Core::hasHeader($this->defaults, 'User-Agent')) { $this->defaults['headers']['User-Agent'] = Utils::getDefaultUserAgent(); } } private function mergeDefaults($options) { $defaults = $this->defaults; if (!empty($defaults['headers']) && !empty($options['headers'])) { $lkeys = []; foreach (array_keys($options['headers']) as $k) { $lkeys[strtolower($k)] = true; } foreach ($defaults['headers'] as $key => $value) { if (!isset($lkeys[strtolower($key)])) { $options['headers'][$key] = $value; } } unset($defaults['headers']); } $result = array_replace_recursive($defaults, $options); foreach ($options as $k => $v) { if ($v === null) { unset($result[$k]); } } return $result; } public function sendAll($requests, array $options = []) { Pool::send($this, $requests, $options); } public static function getDefaultHandler() { return Utils::getDefaultHandler(); } public static function getDefaultUserAgent() { return Utils::getDefaultUserAgent(); } } 