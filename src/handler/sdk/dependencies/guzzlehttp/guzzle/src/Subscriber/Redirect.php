<?php
namespace GuzzleHttp\Subscriber; use GuzzleHttp\Event\CompleteEvent; use GuzzleHttp\Event\RequestEvents; use GuzzleHttp\Event\SubscriberInterface; use GuzzleHttp\Exception\BadResponseException; use GuzzleHttp\Exception\CouldNotRewindStreamException; use GuzzleHttp\Exception\TooManyRedirectsException; use GuzzleHttp\Message\RequestInterface; use GuzzleHttp\Message\ResponseInterface; use GuzzleHttp\Url; class Redirect implements SubscriberInterface { public function getEvents() { return ['complete' => ['onComplete', RequestEvents::REDIRECT_RESPONSE]]; } public static function rewindEntityBody(RequestInterface $redirectRequest) { if ($body = $redirectRequest->getBody()) { if ($body->tell() && !$body->seek(0)) { throw new CouldNotRewindStreamException( 'Unable to rewind the non-seekable request body after redirecting', $redirectRequest ); } } } public function onComplete(CompleteEvent $event) { $response = $event->getResponse(); if (substr($response->getStatusCode(), 0, 1) != '3' || !$response->hasHeader('Location') ) { return; } $request = $event->getRequest(); $config = $request->getConfig(); if ($redirectCount = $config['redirect_count']) { $config['redirect_count'] = ++$redirectCount; } else { $config['redirect_scheme'] = $request->getScheme(); $config['redirect_count'] = $redirectCount = 1; } $max = $config->getPath('redirect/max') ?: 5; if ($redirectCount > $max) { throw new TooManyRedirectsException( "Will not follow more than {$redirectCount} redirects", $request ); } $this->modifyRedirectRequest($request, $response); $event->retry(); } private function modifyRedirectRequest( RequestInterface $request, ResponseInterface $response ) { $config = $request->getConfig(); $protocols = $config->getPath('redirect/protocols') ?: ['http', 'https']; $statusCode = $response->getStatusCode(); if ($statusCode == 303 || ($statusCode <= 302 && $request->getBody() && !$config->getPath('redirect/strict')) ) { $request->setMethod('GET'); $request->setBody(null); } $previousUrl = $request->getUrl(); $this->setRedirectUrl($request, $response, $protocols); $this->rewindEntityBody($request); if ($config->getPath('redirect/referer') && ($request->getScheme() == 'https' || $request->getScheme() == $config['redirect_scheme']) ) { $url = Url::fromString($previousUrl); $url->setUsername(null); $url->setPassword(null); $request->setHeader('Referer', (string) $url); } else { $request->removeHeader('Referer'); } } private function setRedirectUrl( RequestInterface $request, ResponseInterface $response, array $protocols ) { $location = $response->getHeader('Location'); $location = Url::fromString($location); if (!$location->isAbsolute()) { $originalUrl = Url::fromString($request->getUrl()); $originalUrl->getQuery()->clear(); $location = $originalUrl->combine($location); } if (!in_array($location->getScheme(), $protocols)) { throw new BadResponseException( sprintf( 'Redirect URL, %s, does not use one of the allowed redirect protocols: %s', $location, implode(', ', $protocols) ), $request, $response ); } $request->setUrl($location); } } 