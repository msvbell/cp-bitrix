<?php
namespace GuzzleHttp; use GuzzleHttp\Event\BeforeEvent; use GuzzleHttp\Event\RequestEvents; use GuzzleHttp\Message\RequestInterface; use GuzzleHttp\Message\ResponseInterface; use GuzzleHttp\Ring\Core; use GuzzleHttp\Ring\Future\FutureInterface; use GuzzleHttp\Event\ListenerAttacherTrait; use GuzzleHttp\Event\EndEvent; use React\Promise\Deferred; use React\Promise\FulfilledPromise; use React\Promise\PromiseInterface; use React\Promise\RejectedPromise; class Pool implements FutureInterface { use ListenerAttacherTrait; private $client; private $iter; private $deferred; private $promise; private $waitQueue = []; private $eventListeners = []; private $poolSize; private $isRealized = false; public function __construct( ClientInterface $client, $requests, array $options = [] ) { $this->client = $client; $this->iter = $this->coerceIterable($requests); $this->deferred = new Deferred(); $this->promise = $this->deferred->promise(); $this->poolSize = isset($options['pool_size']) ? $options['pool_size'] : 25; $this->eventListeners = $this->prepareListeners( $options, ['before', 'complete', 'error', 'end'] ); } public static function batch( ClientInterface $client, $requests, array $options = [] ) { $hash = new \SplObjectStorage(); foreach ($requests as $request) { $hash->attach($request); } (new self($client, $requests, RequestEvents::convertEventArray( $options, ['end'], [ 'priority' => RequestEvents::LATE, 'fn' => function (EndEvent $e) use ($hash) { $hash[$e->getRequest()] = $e->getException() ? $e->getException() : $e->getResponse(); } ] )))->wait(); return new BatchResults($hash); } public static function send( ClientInterface $client, $requests, array $options = [] ) { $pool = new self($client, $requests, $options); $pool->wait(); } private function getPoolSize() { return is_callable($this->poolSize) ? call_user_func($this->poolSize, count($this->waitQueue)) : $this->poolSize; } private function addNextRequests() { $limit = max($this->getPoolSize() - count($this->waitQueue), 0); while ($limit--) { if (!$this->addNextRequest()) { break; } } } public function wait() { if ($this->isRealized) { return false; } $this->addNextRequests(); if ($this->isRealized) { return false; } while ($response = array_pop($this->waitQueue)) { try { $response->wait(); } catch (\Exception $e) { } $this->addNextRequests(); } $this->isRealized = true; $this->waitQueue = $this->eventListeners = []; $this->client = $this->iter = null; $this->deferred->resolve(true); return true; } public function cancel() { if ($this->isRealized) { return false; } $success = $this->isRealized = true; foreach ($this->waitQueue as $response) { if (!$response->cancel()) { $success = false; } } return $success; } public function then( callable $onFulfilled = null, callable $onRejected = null, callable $onProgress = null ) { return $this->promise->then($onFulfilled, $onRejected, $onProgress); } public function promise() { return $this->promise; } private function coerceIterable($requests) { if ($requests instanceof \Iterator) { return $requests; } elseif (is_array($requests)) { return new \ArrayIterator($requests); } throw new \InvalidArgumentException('Expected Iterator or array. ' . 'Found ' . Core::describeType($requests)); } private function addNextRequest() { add_next: if ($this->isRealized || !$this->iter || !$this->iter->valid()) { return false; } $request = $this->iter->current(); $this->iter->next(); if (!($request instanceof RequestInterface)) { throw new \InvalidArgumentException(sprintf( 'All requests in the provided iterator must implement ' . 'RequestInterface. Found %s', Core::describeType($request) )); } $request->getConfig()->set('future', 'lazy'); $hash = spl_object_hash($request); $this->attachListeners($request, $this->eventListeners); $request->getEmitter()->on('before', [$this, '_trackRetries'], RequestEvents::EARLY); $response = $this->client->send($request); $this->waitQueue[$hash] = $response; $promise = $response->promise(); if ($promise instanceof FulfilledPromise || $promise instanceof RejectedPromise ) { try { $this->finishResponse($request, $response->wait(), $hash); } catch (\Exception $e) { $this->finishResponse($request, $e, $hash); } goto add_next; } $thenFn = function ($value) use ($request, $hash) { $this->finishResponse($request, $value, $hash); if (!$request->getConfig()->get('_pool_retries')) { $this->addNextRequests(); } }; $promise->then($thenFn, $thenFn); return true; } public function _trackRetries(BeforeEvent $e) { $e->getRequest()->getConfig()->set('_pool_retries', $e->getRetryCount()); } private function finishResponse($request, $value, $hash) { unset($this->waitQueue[$hash]); $result = $value instanceof ResponseInterface ? ['request' => $request, 'response' => $value, 'error' => null] : ['request' => $request, 'response' => null, 'error' => $value]; $this->deferred->notify($result); } } 