<?php
namespace GuzzleHttp; use GuzzleHttp\Ring\Core; class Url { private $scheme; private $host; private $port; private $username; private $password; private $path = ''; private $fragment; private static $defaultPorts = ['http' => 80, 'https' => 443, 'ftp' => 21]; private static $pathPattern = '/[^a-zA-Z0-9\-\._~!\$&\'\(\)\*\+,;=%:@\/]+|%(?![A-Fa-f0-9]{2})/'; private static $queryPattern = '/[^a-zA-Z0-9\-\._~!\$\'\(\)\*\+,;%:@\/\?=&]+|%(?![A-Fa-f0-9]{2})/'; private $query; public static function fromString($url) { static $defaults = ['scheme' => null, 'host' => null, 'path' => null, 'port' => null, 'query' => null, 'user' => null, 'pass' => null, 'fragment' => null]; if (false === ($parts = parse_url($url))) { throw new \InvalidArgumentException('Unable to parse malformed ' . 'url: ' . $url); } $parts += $defaults; if ($parts['query'] || 0 !== strlen($parts['query'])) { $parts['query'] = Query::fromString($parts['query']); } return new static($parts['scheme'], $parts['host'], $parts['user'], $parts['pass'], $parts['port'], $parts['path'], $parts['query'], $parts['fragment']); } public static function buildUrl(array $parts) { $url = $scheme = ''; if (!empty($parts['scheme'])) { $scheme = $parts['scheme']; $url .= $scheme . ':'; } if (!empty($parts['host'])) { $url .= '//'; if (isset($parts['user'])) { $url .= $parts['user']; if (isset($parts['pass'])) { $url .= ':' . $parts['pass']; } $url .= '@'; } $url .= $parts['host']; if (isset($parts['port']) && (!isset(self::$defaultPorts[$scheme]) || $parts['port'] != self::$defaultPorts[$scheme]) ) { $url .= ':' . $parts['port']; } } if (isset($parts['path']) && strlen($parts['path'])) { if (!empty($parts['host']) && $parts['path'][0] != '/') { $url .= '/'; } $url .= $parts['path']; } if (isset($parts['query'])) { $queryStr = (string) $parts['query']; if ($queryStr || $queryStr === '0') { $url .= '?' . $queryStr; } } if (isset($parts['fragment'])) { $url .= '#' . $parts['fragment']; } return $url; } public function __construct( $scheme, $host, $username = null, $password = null, $port = null, $path = null, $query = null, $fragment = null ) { $this->scheme = strtolower($scheme); $this->host = $host; $this->port = $port; $this->username = $username; $this->password = $password; $this->fragment = $fragment; if ($query) { $this->setQuery($query); } $this->setPath($path); } public function __clone() { if ($this->query instanceof Query) { $this->query = clone $this->query; } } public function __toString() { return static::buildUrl($this->getParts()); } public function getParts() { return array( 'scheme' => $this->scheme, 'user' => $this->username, 'pass' => $this->password, 'host' => $this->host, 'port' => $this->port, 'path' => $this->path, 'query' => $this->query, 'fragment' => $this->fragment, ); } public function setHost($host) { if (strpos($host, ':') === false) { $this->host = $host; } else { list($host, $port) = explode(':', $host); $this->host = $host; $this->setPort($port); } } public function getHost() { return $this->host; } public function setScheme($scheme) { if ($this->port && isset(self::$defaultPorts[$this->scheme]) && self::$defaultPorts[$this->scheme] == $this->port ) { $this->port = null; } $this->scheme = strtolower($scheme); } public function getScheme() { return $this->scheme; } public function setPort($port) { $this->port = $port; } public function getPort() { if ($this->port) { return $this->port; } elseif (isset(self::$defaultPorts[$this->scheme])) { return self::$defaultPorts[$this->scheme]; } return null; } public function setPath($path) { $this->path = self::encodePath($path); } public function removeDotSegments() { static $noopPaths = ['' => true, '/' => true, '*' => true]; static $ignoreSegments = ['.' => true, '..' => true]; if (isset($noopPaths[$this->path])) { return; } $results = []; $segments = $this->getPathSegments(); foreach ($segments as $segment) { if ($segment == '..') { array_pop($results); } elseif (!isset($ignoreSegments[$segment])) { $results[] = $segment; } } $newPath = implode('/', $results); if (substr($this->path, 0, 1) === '/' && substr($newPath, 0, 1) !== '/' ) { $newPath = '/' . $newPath; } if ($newPath != '/' && isset($ignoreSegments[end($segments)])) { $newPath .= '/'; } $this->path = $newPath; } public function addPath($relativePath) { if ($relativePath != '/' && is_string($relativePath) && strlen($relativePath) > 0 ) { if ($relativePath[0] !== '/' && substr($this->path, -1, 1) !== '/' ) { $relativePath = '/' . $relativePath; } $this->setPath($this->path . $relativePath); } } public function getPath() { return $this->path; } public function getPathSegments() { return explode('/', $this->path); } public function setPassword($password) { $this->password = $password; } public function getPassword() { return $this->password; } public function setUsername($username) { $this->username = $username; } public function getUsername() { return $this->username; } public function getQuery() { if (!$this->query instanceof Query) { $this->query = $this->query === null ? new Query() : Query::fromString($this->query); } return $this->query; } public function setQuery($query, $rawString = false) { if ($query instanceof Query) { $this->query = $query; } elseif (is_string($query)) { if (!$rawString) { $this->query = Query::fromString($query); } else { $this->query = preg_replace_callback( self::$queryPattern, [__CLASS__, 'encodeMatch'], $query ); } } elseif (is_array($query)) { $this->query = new Query($query); } else { throw new \InvalidArgumentException('Query must be a Query, ' . 'array, or string. Got ' . Core::describeType($query)); } } public function getFragment() { return $this->fragment; } public function setFragment($fragment) { $this->fragment = $fragment; } public function isAbsolute() { return $this->scheme && $this->host; } public function combine($url) { $url = static::fromString($url); if (!$this->isAbsolute() && $url->isAbsolute()) { $url = $url->combine($this); } $parts = $url->getParts(); if ($parts['scheme']) { return clone $url; } if ($parts['host']) { return new static( $this->scheme, $parts['host'], $parts['user'], $parts['pass'], $parts['port'], $parts['path'], $parts['query'] instanceof Query ? clone $parts['query'] : $parts['query'], $parts['fragment'] ); } if (!$parts['path'] && $parts['path'] !== '0') { $path = $this->path ?: ''; $query = $parts['query'] ?: $this->query; } else { $query = $parts['query']; if ($parts['path'][0] == '/' || !$this->path) { $path = $parts['path']; } else { $path = substr($this->path, 0, strrpos($this->path, '/') + 1) . $parts['path']; } } $result = new self( $this->scheme, $this->host, $this->username, $this->password, $this->port, $path, $query instanceof Query ? clone $query : $query, $parts['fragment'] ); if ($path) { $result->removeDotSegments(); } return $result; } public static function encodePath($path) { static $cb = [__CLASS__, 'encodeMatch']; return preg_replace_callback(self::$pathPattern, $cb, $path); } private static function encodeMatch(array $match) { return rawurlencode($match[0]); } } 