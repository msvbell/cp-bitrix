<?php
namespace GuzzleHttp; class QueryParser { private $duplicates; private $numericIndices; public function parseInto(Query $query, $str, $urlEncoding = true) { if ($str === '') { return; } $result = []; $this->duplicates = false; $this->numericIndices = true; $decoder = self::getDecoder($urlEncoding); foreach (explode('&', $str) as $kvp) { $parts = explode('=', $kvp, 2); $key = $decoder($parts[0]); $value = isset($parts[1]) ? $decoder($parts[1]) : null; if (strpos($key, '[') !== false) { $this->parsePhpValue($key, $value, $result); continue; } if (!isset($result[$key])) { $result[$key] = $value; } else { $this->duplicates = true; if (!is_array($result[$key])) { $result[$key] = [$result[$key]]; } $result[$key][] = $value; } } $query->replace($result); if (!$this->numericIndices) { $query->setAggregator(Query::phpAggregator(false)); } elseif ($this->duplicates) { $query->setAggregator(Query::duplicateAggregator()); } } private static function getDecoder($type) { if ($type === true) { return function ($value) { return rawurldecode(str_replace('+', ' ', $value)); }; } elseif ($type == Query::RFC3986) { return 'rawurldecode'; } elseif ($type == Query::RFC1738) { return 'urldecode'; } else { return function ($str) { return $str; }; } } private function parsePhpValue($key, $value, array &$result) { $node =& $result; $keyBuffer = ''; for ($i = 0, $t = strlen($key); $i < $t; $i++) { switch ($key[$i]) { case '[': if ($keyBuffer) { $this->prepareNode($node, $keyBuffer); $node =& $node[$keyBuffer]; $keyBuffer = ''; } break; case ']': $k = $this->cleanKey($node, $keyBuffer); $this->prepareNode($node, $k); $node =& $node[$k]; $keyBuffer = ''; break; default: $keyBuffer .= $key[$i]; break; } } if (isset($node)) { $this->duplicates = true; $node[] = $value; } else { $node = $value; } } private function prepareNode(&$node, $key) { if (!isset($node[$key])) { $node[$key] = null; } elseif (!is_array($node[$key])) { $node[$key] = [$node[$key]]; } } private function cleanKey($node, $key) { if ($key === '') { $key = $node ? (string) count($node) : 0; $this->numericIndices = false; } return $key; } } 